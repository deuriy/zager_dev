<?php

namespace BoltCheckout;

if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Provide work around API HTTP requests: prepare answers, close http connection
 *
 * @class   Bolt_HTML_Handler
 * @version 1.0
 * @author  Bolt
 */
class Bolt_HTTP_Handler {

	// Length of HTTP answer
	public static $answer_length = 0;

	// HTTP status of answer
	public static $status = null;

	/**
	 * Prepare HTTP responses.
	 *
	 * @param mixed $data Response data.
	 * @param int $status Optional. HTTP status code. Default 200.
	 * @param array $headers Optional. HTTP header map. Default empty array.
	 *
	 * @return WP_REST_Response/WP_JSON_Response Well-formed response sent to the Bolt Server.
	 * @since 2.0.10
	 *
	 */
	public static function prepare_http_response( $data, $status = HTTP_STATUS_OK, $headers = array() ) {
		// Clean up any strange/useless javascript/html which may be generated by some other plugins unexpectedly,
		// cause these javascript/html would eventually break the Bolt api response.
		self::clean_buffers();

		// Only when responding error message, $data is array and contains ['error']['message']
		if ( is_array( $data ) && isset( $data[ BOLT_FIELD_NAME_ERROR ][ BOLT_FIELD_NAME_ERROR_MESSAGE ] ) ) {
			$data[ BOLT_FIELD_NAME_ERROR ][ BOLT_FIELD_NAME_ERROR_MESSAGE ] = strip_tags( html_entity_decode( $data[ BOLT_FIELD_NAME_ERROR ][ BOLT_FIELD_NAME_ERROR_MESSAGE ] ) );
		}
		self::$answer_length = strlen( json_encode( $data ) );
		self::$status        = $status;

		if ( WC_BOLT_WP_REST_API_ADDON ) {
			$response = new \WP_JSON_Response();
			$response->set_data( $data );
			$response->set_status( $status );
			$response->set_headers(
				array_merge( $headers, array(
					'X-User-Agent'          => 'BoltPay/WooCommerce-' . WC()->version . '/' . WC_BOLT_CHECKOUT_VERSION,
					'X-Bolt-Plugin-Version' => WC_BOLT_CHECKOUT_VERSION
				) )
			);

			return $response;
		} else {
			return new \WP_REST_Response(
				$data,
				$status,
				array_merge( $headers, array(
					'X-User-Agent'          => 'BoltPay/WooCommerce-' . WC()->version . '/' . WC_BOLT_CHECKOUT_VERSION,
					'X-Bolt-Plugin-Version' => WC_BOLT_CHECKOUT_VERSION
				) )
			);
		}
	}

	/**
	 * Sends output immediately to the Bolt server without ending script execution
	 * @since 2.0.10
	 *
	 */
	public static function close_connection() {
		// Close HTTP connection to flush output to Bolt so that
		// we can do database cleanup without blocking

		// This will handle flushing for Apache
		header( 'Content-Encoding: none' );
		header( 'Content-Length: ' . ( self::$answer_length ) );
		header( 'Connection: Close' );
		if ( session_id() ) {
			session_write_close();
		}

		// Send the prepared output
		$ob_level = ob_get_level();
		while ( $ob_level > 0 ) {
			ob_flush();
			$ob_level --;
		}

		flush();

		// Code to flush on Ngnix/PHP-FPM
		if ( function_exists( 'fastcgi_finish_request' ) ) {
			fastcgi_finish_request();
		}
	}

	/**
	 * Clean all output buffers, can prevent errors.
	 *
	 * @param bool $need_log Whether to log the buffers to bugsnag
	 *
	 * @return array Returns the buffered
	 * @since 2.3.0
	 */
	public static function clean_buffers( $need_log = false ) {
		$buffers = array();
		if ( ob_get_level() ) {
			$previous = null;
			while ( ( $level = ob_get_level() ) > 0 && $level !== $previous ) {
				$previous = $level;
				$buffer   = @ob_get_contents();
				if ( ! empty( $buffer ) ) {
					$buffers[] = $buffer;
				}
				@ob_end_clean(); // phpcs:ignore Generic.PHP.NoSilencedErrors.Discouraged
			}
		} else {
			@ob_end_clean(); // phpcs:ignore Generic.PHP.NoSilencedErrors.Discouraged
		}

		if ( $need_log && ! empty( $buffers ) ) {
			BugsnagHelper::notifyException( new \Exception( __( 'Output buffers.', 'bolt-checkout-woocommerce' ) ), $buffers, 'info' );
		}

		return $buffers;
	}
}
